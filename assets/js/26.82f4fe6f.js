(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{538:function(t,e,s){t.exports=s.p+"assets/img/gitflow.ded3cd89.jpg"},663:function(t,e,s){"use strict";s.r(e);var a=s(1),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是gitflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是gitflow"}},[t._v("#")]),t._v(" 什么是Gitflow")]),t._v(" "),a("ul",[a("li",[t._v("在工作场合实施Git的时候，有很多种工作流程可供选择，此时反而会让你手足无措。本文罗列了企业团队最常用的一些git工作流程，包括Centralized Workflow、Feature Branch Workflow、Gitflow Workflow、Forking Workflow。愿以此文抛砖引玉。\n在你开始阅读之前，请记住：这些流程应被视作为指导方针，而非“铁律”。我们只是想告诉你可能的做法。因此，如果有必要的话，你可以组合使用不同的流程。")])]),t._v(" "),a("ol",[a("li",[t._v("它是怎么工作的？")])]),t._v(" "),a("ul",[a("li",[t._v("Gitflow流程仍然使用一个中央代码仓库，它是所有开发者的信息交流中心。跟其他的工作流程一样，开发者在本地完成开发，然后再将分支代码推送到中央仓库。唯一不同的是项目中分支的结构。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("用于记录历史的分支")])]),t._v(" "),a("ul",[a("li",[t._v("Gitflow使用两个分支来记录项目开发的历史，而不是使用单一的master分支。在Gitflow流程中，master只是用于保存官方的发布历史，而develop分支才是用于集成各种功能开发的分支。使用版本号为master上的所有提交打标签（tag）也很方便。")]),t._v(" "),a("li",[t._v("事实上，Gitflow流程就是围绕这两个特点鲜明的分支展开的。")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("用于功能开发的分支")])]),t._v(" "),a("ul",[a("li",[t._v("每一个新功能的开发都应该各自使用独立的分支。为了备份或便于团队之间的合作，这种分支也可以被推送到中央仓库。但是，在创建新的功能开发分支时，父分支应该选择develop（而不是master）。当功能开发完成时，改动的代码应该被合并（merge）到develop分支。功能开发永远不应该直接牵扯到master。")]),t._v(" "),a("li",[t._v("注意：组合使用功能开发分支和develop分支的这种设计，其实完全就是Feature Branch Workflow的理念。然而，Gitflow流程并不止于此。")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("用于发布的分支")])]),t._v(" "),a("ul",[a("li",[t._v("一旦develop分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于develop分支建立一个用于产品发布的分支。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能——在这个分支上只能修复bug，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入master，并且用版本号打上标签。另外，发布分支上的改动还应该合并入develop分支——在发布周期内，develop分支仍然在被使用（一些开发者会把其他功能集成到develop分支）。")]),t._v(" "),a("li",[t._v("使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。这也有助于清晰表明开发的状态，比如说，团队在汇报状态时可以轻松使用这样的措辞，“这星期我们要为发布4.0版本做准备。”从代码仓库的结构上也能直接反映出来。常用的一些措辞还有：基于develop新建分支，合并入master；命名规则为：release-或release/")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("用于维护的分支")])]),t._v(" "),a("ul",[a("li",[t._v("发布后的维护工作或者紧急问题的快速修复也需要使用一个独立的分支。这是唯一一种可以直接基于master创建的分支。一旦问题被修复了，所做的改动应该被合并入master和develop分支（或者用于当前发布的分支）。在这之后，master上还要使用更新的版本号打好标签。")]),t._v(" "),a("li",[t._v("这种为解决紧急问题专设的绿色通道，让团队不必打乱当前的工作流程，也不必等待下一次的产品发布周期。你可以把用于维护的分支看成是依附于master的一种特别的发布分支。")])]),t._v(" "),a("p",[t._v("gitflow流程图示意")]),t._v(" "),a("p",[a("img",{attrs:{src:s(538),alt:"gitflow"}})]),t._v(" "),a("h2",{attrs:{id:"gitflow模拟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gitflow模拟"}},[t._v("#")]),t._v(" Gitflow模拟")]),t._v(" "),a("ul",[a("li",[t._v("下面的例子将演示Gitflow流程如何被用来管理一次产品发布。假设你已经创建好了一个中央仓库。")])]),t._v(" "),a("ol",[a("li",[t._v("创建develop分支")])]),t._v(" "),a("ul",[a("li",[t._v("第一步是给默认的master配备一个develop分支。一种简单的做法是：让一个开发者在本地建立一个空的develop分支，然后把它推送到服务器。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git branch develop\ngit push "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("u origin develop\n")])])]),a("ul",[a("li",[t._v("develop分支将包含项目的所有历史，而master会是一个缩减版本。现在，其他开发者应该克隆（clone）中央仓库，并且为develop创建一个追踪分支。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git clone ssh"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("user@host"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("repo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("git\ngit checkout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("b develop origin"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("develop\n")])])]),a("ul",[a("li",[t._v("到现在，所有人都把包含有完整历史的分支（develop）在本地配置好了。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("两个开发人员（A和B）同步开发两个新功能")])]),t._v(" "),a("ul",[a("li",[t._v("他们俩各自建立了自己的分支。注意，他们在创建分支时，父分支不能选择master，而要选择develop。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git checkout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("b some"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("feature develop\n")])])]),a("ul",[a("li",[t._v("他们俩都在自己的功能开发分支上开展工作。通常就是这种Git三部曲：edit，stage，")]),t._v(" "),a("li",[t._v("提交的时候")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git status\ngit add "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("some"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("file"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\ngit commit\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("A的功能开发好了")])]),t._v(" "),a("ul",[a("li",[t._v("在提交过几次代码之后，A觉得他的功能做完了。如果他所在的团队使用“拉拽请求”，此刻便是一个合适的时机——他可以提出一个将他所完成的功能合并入develop分支的请求。要不然，他可以自行将他的代码合并入本地的develop分支，然后再推送到中央仓库，像这样")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git pull origin develop\ngit checkout develop\ngit merge some"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("feature\ngit push\ngit branch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("d some"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("feature\n")])])]),a("ul",[a("li",[t._v("第一条命令确保了本地的develop分支拥有最新的代码——这一步必须在将功能代码合并之前做！注意，新开发的功能代码永远不能直接合并入master。必要时，还需要解决在代码合并过程中的冲突。")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("A开始准备一次发布")])]),t._v(" "),a("ul",[a("li",[t._v("B还在忙着开发他的功能，A却可以开始准备这个项目的第一次正式发布了。类似于功能开发，他使用了一个新的分支来做产品发布的准备工作。在这一步，发布的版本号也最初确定下来。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git checkout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("b release"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v(" develop\n")])])]),a("ul",[a("li",[t._v("这个分支专门用于发布前的准备，包括一些清理工作、全面的测试、文档的更新以及任何其他的准备工作。它与用于功能开发的分支相似，不同之处在于它是专为产品发布服务的。")]),t._v(" "),a("li",[t._v("A创建了这个分支并把它推向中央仓库，这次产品发布包含的功能也就固定下来了。任何还处于开发状态的功能只能等待下一个发布周期。")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("A完成了发布")])]),t._v(" "),a("ul",[a("li",[t._v("一切准备就绪之后，A就要把发布分支合并入master和develop分支，然后再将发布分支删除。注意，往develop分支的合并是很重要的，因为开发人员可能在发布分支上修复了一些关键的问题，而这些修复对于正在开发中的新功能是有益的。再次提醒一下，如果A所在的团队强调代码评审（Code Review），此时非常适合提出这样的请求。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git checkout master\ngit merge release"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\ngit push\ngit checkout develop\ngit merge release"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\ngit push\ngit branch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("d release"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v("\n")])])]),a("ul",[a("li",[t._v("发布分支扮演的角色是功能开发（develop）与官方发布（master）之间的一个缓冲。无论什么时候你把一些东西合并入master，你都应该随即打上合适的标签。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git tag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("m"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Initial public release"')]),t._v(" master\ngit push "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("tags\n")])])]),a("ul",[a("li",[t._v("Git支持钩子（hook）的功能，也就是说，在代码仓库里某些特定的事件发生的时候，可以执行一些预定义的脚本。因此，一种可行的做法是：在服务器端配置一个钩子，当你把master推送到中央仓库或者推送标签时，Git服务器能为产品发布进行一次自动的构建。")])]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[t._v("用户发现了一个bug")])]),t._v(" "),a("ul",[a("li",[t._v("当一次发布完成之后，A便回去与B一起开发其他功能了。突然，某个用户提出抱怨说当前发布的产品里有一个bug。为了解决这个问题，A（或者B）基于master创建了一个用于维护的分支。他在这个分支上修复了那个bug，然后把改动的代码直接合并入master。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git checkout "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("b issue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("#"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("001")]),t._v(" master\n\\# Fix the bug\ngit checkout master\ngit merge issue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("#"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("001")]),t._v("\ngit push\n")])])]),a("ul",[a("li",[t._v("跟用于发布的分支一样，在维护分支上的改动也需要合并入develop分支，这一点是很重要的！因此，A务必不能忘了这一步。随后，他就可以将维护分支删除。")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("git checkout develop\ngit merge issue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("#"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("001")]),t._v("\ngit push\ngit branch "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("d issue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("#"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("001")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);