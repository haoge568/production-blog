(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{645:function(t,a,_){"use strict";_.r(a);var e=_(1),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"react知识汇总"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react知识汇总"}},[t._v("#")]),t._v(" react知识汇总")]),t._v(" "),_("h3",{attrs:{id:"_1-jsx"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-jsx"}},[t._v("#")]),t._v(" 1.Jsx")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义：它是React.createElement语法糖，它是基于diff算法通过js生成的虚拟dom；看上去很像html/xml")]),t._v(" "),_("li",[t._v("(2)总结：js生成的dom片段(最low的说法)")])]),t._v(" "),_("h3",{attrs:{id:"_2-diff算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-diff算法"}},[t._v("#")]),t._v(" 2.Diff算法")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义：同层对比，新元素替换旧元素的一种快速计算虚拟dom的算法；")])]),t._v(" "),_("h3",{attrs:{id:"_3-常用顶级api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-常用顶级api"}},[t._v("#")]),t._v(" 3.常用顶级api")]),t._v(" "),_("ul",[_("li",[t._v("(1)ReactDOM.render")]),t._v(" "),_("li",[t._v("(2)ReactDOM.createProtal")]),t._v(" "),_("li",[t._v("(3)React.createElement")]),t._v(" "),_("li",[t._v("(4)React.Children")]),t._v(" "),_("li",[t._v("(5)React.cloneElement")]),t._v(" "),_("li",[t._v("(6)React.createContext")]),t._v(" "),_("li",[t._v("(7)React.createRef")]),t._v(" "),_("li",[t._v("(8)React.forwardRef")]),t._v(" "),_("li",[t._v("(9)React.lazy")]),t._v(" "),_("li",[t._v("(10)React.Fargement")]),t._v(" "),_("li",[t._v("(11)React.Component")]),t._v(" "),_("li",[t._v("(12)React.pureComponent")])]),t._v(" "),_("h3",{attrs:{id:"_4-组件类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-组件类型"}},[t._v("#")]),t._v(" 4.组件类型")]),t._v(" "),_("ul",[_("li",[t._v("(1)Function:无状态组件")]),t._v(" "),_("li",[t._v("①定义:没有react特性，它只有一个props属性;")]),t._v(" "),_("li",[t._v("②优点:加载快，渲染快，执行快。")]),t._v(" "),_("li",[t._v("③缺点:没有react其它特性，功能单一；")]),t._v(" "),_("li",[t._v("④适用于:ui组件，纯dom组件；")]),t._v(" "),_("li",[t._v("⑤也可以有生命周期")]),t._v(" "),_("li",[t._v("(2)Class:功能组件")]),t._v(" "),_("li",[t._v("①定义:拥有react全部特性，功能强大;")]),t._v(" "),_("li",[t._v("②优点:功能强大，有生命周期，有状态和props")]),t._v(" "),_("li",[t._v("③缺点:因为class组件会被实例化，实例化对象会常驻内容；加载、渲染相对于无状态组件慢")]),t._v(" "),_("li",[t._v("④适用于:存放逻辑和请求接口的功能性组件；")]),t._v(" "),_("li",[t._v("(3)hoc高阶组件")]),t._v(" "),_("li",[t._v("①定义:一个函数接受一个组件，返回一个class组件；它是一种组合方式，不是api")]),t._v(" "),_("li",[t._v("②作用:将一些可多次复用的逻辑和方法封装到高阶组件中；实现逻辑方法的复用；")])]),t._v(" "),_("h3",{attrs:{id:"_5-样式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-样式"}},[t._v("#")]),t._v(" 5. 样式")]),t._v(" "),_("ul",[_("li",[t._v("(1)React中写css文件，它会充斥整个的项目作用域里，很容易造成样式污染；")]),t._v(" "),_("li",[t._v("(2)Css模块化:")]),t._v(" "),_("li",[t._v("①Css.module:这是官方脚手架提供的css模块化")]),t._v(" "),_("li",[t._v("②Style-component:一个第三方库，将css写在js文件中；")])]),t._v(" "),_("h3",{attrs:{id:"_6-state"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-state"}},[t._v("#")]),t._v(" 6.State")]),t._v(" "),_("ul",[_("li",[t._v("(1)状态:只有class组件有，它是组件自身的状态；")]),t._v(" "),_("li",[t._v("(2)注意:不能直接修改，以为在规定里state是只读的，修改必须使用setState")]),t._v(" "),_("li",[t._v("(3)为什么必须使用setState:因为只有使用setState才能使组件进入更新阶段")]),t._v(" "),_("li",[t._v("(4)SetState写法:")]),t._v(" "),_("li",[t._v("①第一种:在setState函数中直接传入一个对象；这种修改是默认的异步修改")]),t._v(" "),_("li",[t._v("②第二种:在setState函数中传入两个回调函数；这种修改时将异步修改变成同步；第一个函数里返回要修改的state；第二个函数里获取被修改后的state；")])]),t._v(" "),_("h3",{attrs:{id:"_7-props"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-props"}},[t._v("#")]),t._v(" 7.Props")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义:由父级传进来的属性值(数据)、组件自身不能修改，必须交由父级去修改；")]),t._v(" "),_("li",[t._v("(2)注意:元素上创建自定义数据必须全小写")]),t._v(" "),_("li",[t._v("(3)对比一下它和状态的相同点和区别")]),t._v(" "),_("li",[t._v("①相同点:都是存数据的，被修改后都会触发组件的更新阶段")]),t._v(" "),_("li",[t._v("②不同点:props只能由父级修改，state组件自身可以修改")])]),t._v(" "),_("h3",{attrs:{id:"_8-事件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-事件"}},[t._v("#")]),t._v(" 8.事件")]),t._v(" "),_("ul",[_("li",[t._v("(1)在react里事件和事件对象(event)都叫合成事件/对象;")]),t._v(" "),_("li",[t._v("(2)在class组件中声明事件方法的时候需要用箭头函数的形式解决this指针问题;")]),t._v(" "),_("li",[t._v("(3)为什么用箭头函数可以解决this指针:因为箭头函数自身没有this，它会在最近的作用域中找this；")]),t._v(" "),_("li",[t._v("(4)Event对象中常用的5个属性:currentTarget[获取事件绑定的元素]、target[获取被触发的元素]、清冒泡stoppropagetion、禁止默认preventDefault、persist")]),t._v(" "),_("li",[t._v("(5)Event对象在异步的事件中会导致属性值丢失，所以使用event.persist来强制保留属性值；")])]),t._v(" "),_("h3",{attrs:{id:"_9-生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-生命周期"}},[t._v("#")]),t._v(" 9.生命周期")]),t._v(" "),_("ul",[_("li",[t._v("(1)挂载阶段:constructor、render、componentDidMount")]),t._v(" "),_("li",[t._v("(2)更新阶段:render、componentDidUpdate")]),t._v(" "),_("li",[t._v("(3)卸载阶段:componentWillUnmount")]),t._v(" "),_("li",[t._v("(4)不常用:shouldComponentUpdate:用来优化组件更新")])]),t._v(" "),_("h3",{attrs:{id:"_10-表单"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-表单"}},[t._v("#")]),t._v(" 10.表单")]),t._v(" "),_("ul",[_("li",[t._v("(1)需要注意的一件事:button按钮必须指定类型，不然他的默认类型就是submit;")]),t._v(" "),_("li",[t._v("(2)表单上默认提交的方法:onSubmit、重置表单:onReset")])]),t._v(" "),_("h3",{attrs:{id:"_11-列表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-列表"}},[t._v("#")]),t._v(" 11.列表")]),t._v(" "),_("ul",[_("li",[t._v("(1)需要注意的一件事:在数组上下文环境中【[]和循环体】中，兄弟元素需要加key;这个key是给diff算法用的;这个key必须得是当前数组上下文环境中唯一的；不能用随机数、时间戳来做key，不得已的情况下使用index下标，尽量用id去做key;")])]),t._v(" "),_("h3",{attrs:{id:"_12-性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-性能优化"}},[t._v("#")]),t._v(" 12.性能优化")]),t._v(" "),_("ul",[_("li",[t._v("(1)懒加载:React.lazy();")]),t._v(" "),_("li",[t._v("(2)控制组件更新:shouldConponentUpdata")]),t._v(" "),_("li",[t._v("(3)自动优化组件更新基类:React.pureComponent")])]),t._v(" "),_("h3",{attrs:{id:"_13-受控组件和非受控组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-受控组件和非受控组件"}},[t._v("#")]),t._v(" 13.受控组件和非受控组件")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义:受控组件是受react控制其行为状态的组件叫受控组件,比如说input value值用state控制，必须使用onchange事件来控制输入;")]),t._v(" "),_("li",[t._v("(2)非受控,不收react控制其行为状态;比如说input元素的type值为file，由于文件上传元素的value值是只读的，所以不能够用state来控制;")])]),t._v(" "),_("h3",{attrs:{id:"_14-ref获取dom元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-ref获取dom元素"}},[t._v("#")]),t._v(" 14.Ref获取dom元素")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义:获取dom元素的")]),t._v(" "),_("li",[t._v("(2)语法:React.createRef()将ref对象绑定到元素上，使用ref对象里的current获取dom元素")]),t._v(" "),_("li",[t._v("(3)转发:将父组件里的ref对象转发给子组件，用于获取子组件内的dom元素；")]),t._v(" "),_("li",[t._v("(4)转发的子组件必须使用React.forwardRef方法声明")])]),t._v(" "),_("h3",{attrs:{id:"_15-状态提升和上下文对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-状态提升和上下文对象"}},[t._v("#")]),t._v(" 15.状态提升和上下文对象")]),t._v(" "),_("ul",[_("li",[t._v("(1)状态提升:用props，集中管理子组件的数据")]),t._v(" "),_("li",[t._v("(2)上下文对象:用context，连接根组件和后代组件")]),t._v(" "),_("li",[t._v("(3)上下文对象解决了什么问题？解决了props显式传递数据造成数据丢失和难以维护的问题;")]),t._v(" "),_("li",[t._v("(4)语法:")]),t._v(" "),_("li",[t._v("①1.创建上下文对象const context = React.createContext()")]),t._v(" "),_("li",[t._v("②2.根容器中 <context.Provider value={data}>")]),t._v(" "),_("li",[_("Child")],1),t._v(" "),_("li",[t._v("</context.Provider>")]),t._v(" "),_("li",[t._v("③在子组件中")]),t._v(" "),_("li",[t._v("<context.Consumer>{(data)=>{...}}</context.Consumer>")]),t._v(" "),_("li",[t._v("(5)执行过程:从Consumer组件向上查找Provider组件,一旦找到，就获取Provider数据的value值;")])]),t._v(" "),_("h3",{attrs:{id:"_16-懒加载又叫代码分割"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-懒加载又叫代码分割"}},[t._v("#")]),t._v(" 16.懒加载又叫代码分割")]),t._v(" "),_("ul",[_("li",[t._v("(1)解决了什么问题？优点？干什么用的？优化性能，按需加载组件；减少打包后单文件体积,将首屏不直接显示的组件拆分成独立的小文件;")]),t._v(" "),_("li",[t._v("(2)优点:减少首屏加载的时间、按需加载组件、提高用户体验；")]),t._v(" "),_("li",[t._v("(3)缺点:增加了http请求次数，容易导致加载失败的问题")]),t._v(" "),_("li",[t._v("(4)注意:合理的使用lazy，如果代码特别少，或者首屏需要默认展示的都不要用lazy；对于大量的代码的组件并且不需要在首屏出现- 的使用lazy")]),t._v(" "),_("li",[t._v("(5)代码示例:")])]),t._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[t._v("①Const Com "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("‘"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("path’"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n②"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("React"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Suspense fallback"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("’加载中"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("’"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Com"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("React"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Suspense"),_("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),_("h3",{attrs:{id:"_17-条件渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-条件渲染"}},[t._v("#")]),t._v(" 17.条件渲染")]),t._v(" "),_("ul",[_("li",[t._v("(1)定义:根据一个条件来控制元素的状态;")]),t._v(" "),_("li",[t._v("(2)写法:if  switch  三目运算  &&  ||  !")]),t._v(" "),_("li",[t._v("18.组合模式")]),t._v(" "),_("li",[t._v("(1)直接在组件中使用自定义组件")]),t._v(" "),_("li",[t._v("(2)Class组件中使用无状态组件")]),t._v(" "),_("li",[t._v("(3)插槽模式:在被插入的组件中使用props.children")])]),t._v(" "),_("h3",{attrs:{id:"_19-脚手架配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_19-脚手架配置"}},[t._v("#")]),t._v(" 19.脚手架配置")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("(1)代理--跨域:在package.json写入”proxy”:”http://path.com”")])]),t._v(" "),_("li",[_("code",[t._v("(2)打包的时候配置二级目录:在package.json文件里面写入”pagehome”:”./”")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);