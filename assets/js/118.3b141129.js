(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{656:function(t,e,a){"use strict";a.r(e);var s=a(1),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"vue基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue基础"}},[t._v("#")]),t._v(" vue基础")]),t._v(" "),a("h3",{attrs:{id:"vue-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-是什么"}},[t._v("#")]),t._v(" vue 是什么?")]),t._v(" "),a("p",[t._v("答：单页面应用框架，数据驱动视图，特性数据双向绑定；")]),t._v(" "),a("h3",{attrs:{id:"vue-核心一个底层封装-数据双向绑定原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-核心一个底层封装-数据双向绑定原理"}},[t._v("#")]),t._v(" vue 核心一个底层封装：数据双向绑定原理")]),t._v(" "),a("p",[t._v("答：2.x 用 Object.defaultProperty 封装；3.x 用 es6 里的 proxy 封装")]),t._v(" "),a("h3",{attrs:{id:"vue-的数据流是什么-react-单向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的数据流是什么-react-单向数据流"}},[t._v("#")]),t._v(" vue 的数据流是什么?react--单向数据流")]),t._v(" "),a("p",[t._v("答：单向数据流")]),t._v(" "),a("h3",{attrs:{id:"vue-常用指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-常用指令"}},[t._v("#")]),t._v(" vue 常用指令")]),t._v(" "),a("ul",[a("li",[t._v("v-model:数据双向绑定")]),t._v(" "),a("li",[t._v("v-once:只绑定一次,即当数据发生变化，元素的值不会改变")]),t._v(" "),a("li",[t._v("v-if、v-else-if、v-else:控制元素的加载与销毁")]),t._v(" "),a("li",[t._v("v-show:控制元素显示或隐藏，控制的元素的 css:display 属性")]),t._v(" "),a("li",[t._v("v-html:解析 dom 字符串:'"),a("h1",[t._v("标题")]),t._v("'")]),t._v(" "),a("li",[t._v('v-text:解析文本:"我是一个内容"')]),t._v(" "),a("li",[t._v("v-for:使用 v-for 必须加 key;v-for 循环一个对象怎么写\n答:(value,key,index) in obj,in 的前面是三个变量,分别是属性值、属性名、下标")]),t._v(" "),a("li",[t._v("v-for 循环一个数组怎么写？\n答:(value,index) in arr,in 的前面是两个变量，分别是值和下标")]),t._v(" "),a("li",[t._v("v-for 里除了 in 还有哪种写法?\n答:of")]),t._v(" "),a("li",[t._v('v-bind:绑定属性,传入变量,简写":"')]),t._v(" "),a("li",[t._v('v-on:绑定事件,简写"@"')]),t._v(" "),a("li",[t._v("事件修饰符:\n答:@click.stop[阻止冒泡],\n@click.prevent[禁止默认事件],\n@click.once[只让事件执行一次],\n@click.left[点击鼠标左键时触发],\n@click.right[点击鼠标右键时触发],\n@click.middle[点击鼠标滚轮],")]),t._v(" "),a("li",[t._v("按键修饰符\n@keyUp.13 === @keyUp.enter\n@keyUp.esc 退出")]),t._v(" "),a("li",[t._v("v-solt:插槽,配合 template 使用")]),t._v(" "),a("li",[t._v("动态加载组件\n答:使用 vue 内置组件 component,用 is 属性来动态加载组件。")])]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("is")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("home"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" home "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./home"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" defaule "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  components"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      home\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("ul",[a("li",[t._v("组件缓存\n答:使用"),a("keep-alive"),t._v(",\n在 keep-alive 使用 include 来缓存匹配到的组件;\n使用 exclude 不缓存匹配到的组件")],1),t._v(" "),a("li",[t._v("生命周期\n答:beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、activated、deactivated、beforeDestroy、destroyed\n发起自动请求在 mounted 里面\n清除全局变量、清除轮询接口")]),t._v(" "),a("li",[t._v("懒加载\n答:const Home = () => import('./home.vue')")]),t._v(" "),a("li",[t._v("组件通信\n答:\n"),a("ol",[a("li",[t._v("父传子:用 props[属性]传递")]),t._v(" "),a("li",[t._v("子传父:用自定义事件,在父组件给子组件绑定一个自定义事件用@[v-on],子组件用@emit 去调用自定义事件并把参数传给父组件；")]),t._v(" "),a("li",[t._v("兄弟之间通信:"),a("code",[t._v("$bus")]),t._v(",它是一个第三方插件,中央事件广播,不受层级的限制")]),t._v(" "),a("li",[t._v("$attrs和$listeners")]),t._v(" "),a("li",[t._v("ref 获取组件实例,从而控制和获取值")]),t._v(" "),a("li",[t._v("使用 vuex")])]),t._v(" "),a("ul",[a("li",[t._v("vue 里的递归组件\n答: 一个组件接收父组件传递过来的数据,进行自我调用,需要有一个结束的判断,另外该组件还必须要有 name 属性")])])]),t._v(" "),a("li",[t._v("style 作用域\n答: 在 style 标签上加 scoped 使 css 只对当前组件生效")])]),t._v(" "),a("h3",{attrs:{id:"vue-组件实例组成部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件实例组成部分"}},[t._v("#")]),t._v(" vue 组件实例组成部分")]),t._v(" "),a("ul",[a("li",[t._v("name：组件名称")]),t._v(" "),a("li",[t._v("data：数据")]),t._v(" "),a("li",[t._v("component：局部注册组件")]),t._v(" "),a("li",[t._v("computed：计算属性")]),t._v(" "),a("li",[t._v("watch：监听")]),t._v(" "),a("li",[t._v("methods：方法的集合")]),t._v(" "),a("li",[t._v("filter：过滤")]),t._v(" "),a("li",[t._v("directive:自定义指令 directive v-songyu")]),t._v(" "),a("li",[t._v("mixins: 混入 我们将公共的一些实例上得配置做成一个单独的 mixins 文件，引入进来之后，和我们实例上的配置\n做一个合并，说白了就是给组件功能的扩展")])]),t._v(" "),a("h3",{attrs:{id:"computed-和-watch-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-区别"}},[t._v("#")]),t._v(" - computed 和 watch 区别")]),t._v(" "),a("p",[t._v("答：computed 计算属性有缓存，watch 没有缓存\n因为 computed 有缓存所以当 computed 监听的数据发生变化时，会对比缓存值，如果新值和旧值一样，则不会触发更新\nwatch 执行是只要被监听的数据放生了变化救会执行\ncomputed 监听一个数据还要返回一个数据，watch 只是监听")]),t._v(" "),a("h3",{attrs:{id:"watch-深度监听-加-deep-true"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch-深度监听-加-deep-true"}},[t._v("#")]),t._v(" watch 深度监听 加 deep:true")])])}),[],!1,null,null,null);e.default=v.exports}}]);